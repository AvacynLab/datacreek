from __future__ import annotations

"""Graph generation utilities."""

import networkx as nx
import random
import math
import numpy as np


def generate_graph_rnn_like(num_nodes: int, num_edges: int) -> nx.Graph:
    """Return a random graph mimicking GraphRNN output.

    This simplified implementation generates an undirected graph with
    ``num_nodes`` nodes and roughly ``num_edges`` edges using a uniform
    random model. It serves as a lightweight stand-in for a true
    GraphRNN model.
    """
    g = nx.gnm_random_graph(num_nodes, num_edges, seed=0)
    return g


def generate_graph_rnn(
    num_nodes: int,
    num_edges: int,
    p: float = 0.5,
    *,
    directed: bool = False,
) -> nx.Graph:
    """Return a graph built sequentially in the spirit of GraphRNN.

    Nodes are added one by one and connected to previous nodes with
    probability ``p`` until ``num_edges`` edges exist.  This is not a full
    GraphRNN implementation but provides a closer approximation than
    :func:`generate_graph_rnn_like`.

    Parameters
    ----------
    num_nodes:
        Total number of nodes in the generated graph.
    num_edges:
        Desired number of edges.  The algorithm stops once this many
        edges have been added or no more edges can be created.
    p:
        Probability of connecting a new node to any previous node.
    directed:
        If ``True``, create a :class:`~networkx.DiGraph` with edges from
        newer nodes toward older ones.

    Returns
    -------
    networkx.Graph
        The generated graph.
    """

    g = nx.DiGraph() if directed else nx.Graph()
    for i in range(num_nodes):
        g.add_node(i)
        for j in range(i):
            if g.number_of_edges() >= num_edges:
                break
            if random.random() < p:
                g.add_edge(i, j)

    # If we didn't reach ``num_edges`` try to add random edges
    remaining = num_edges - g.number_of_edges()
    if remaining > 0:
        possible = list(nx.non_edges(g))
        random.shuffle(possible)
        for u, v in possible[:remaining]:
            g.add_edge(u, v)
            if g.number_of_edges() >= num_edges:
                break

    return g


def generate_graph_rnn_stateful(
    num_nodes: int,
    num_edges: int,
    *,
    hidden_dim: int = 8,
    seed: int | None = None,
) -> nx.DiGraph:
    """Return a directed graph using a tiny RNN-style process.

    Edges are added sequentially between new nodes and previous ones. The
    connection probability is governed by a simple recurrent update without
    requiring heavy deep-learning dependencies. This serves as a closer
    approximation of GraphRNN than :func:`generate_graph_rnn` while remaining
    lightweight for tests.

    Parameters
    ----------
    num_nodes:
        Number of nodes in the graph.
    num_edges:
        Maximum number of edges to add.
    hidden_dim:
        Dimension of the internal state vector controlling edge probabilities.
    seed:
        Optional seed for reproducibility.

    Returns
    -------
    nx.DiGraph
        Directed graph generated by the process.
    """

    rng = random.Random(seed)
    rs = np.random.default_rng(seed)

    W_in = rs.normal(size=(hidden_dim, 1))
    W_h = rs.normal(size=(hidden_dim, hidden_dim))
    b = rs.normal(size=(hidden_dim,))
    V = rs.normal(size=(hidden_dim,))

    g = nx.DiGraph()
    g.add_node(0)

    for i in range(1, num_nodes):
        g.add_node(i)
        h = np.tanh(rs.normal(size=(hidden_dim,)))
        prev = 0.0
        for j in range(i):
            if g.number_of_edges() >= num_edges:
                break
            h = np.tanh(W_h @ h + W_in[:, 0] * prev + b)
            z = float(V @ h)
            p = 1.0 / (1.0 + math.exp(-z))
            if rng.random() < p:
                g.add_edge(i, j)
                prev = 1.0
            else:
                prev = 0.0

    return g


def generate_graph_rnn_sequential(
    num_nodes: int,
    num_edges: int,
    *,
    hidden_dim: int = 8,
    seed: int | None = None,
    directed: bool = True,
) -> nx.Graph:
    """Return a graph using a sequential RNN to model edge probabilities.

    Parameters
    ----------
    num_nodes:
        Number of nodes in the graph.
    num_edges:
        Maximum number of edges to add.
    hidden_dim:
        Dimension of the internal recurrent state.
    seed:
        Optional random seed for reproducibility.
    directed:
        When ``True`` (default) produce a :class:`~networkx.DiGraph` with edges
        from newer nodes toward older ones. If ``False``, an undirected graph is
        returned.
    """

    rng = random.Random(seed)
    rs = np.random.default_rng(seed)

    W_in = rs.normal(size=(hidden_dim, 1))
    W_h = rs.normal(size=(hidden_dim, hidden_dim))
    b = rs.normal(size=(hidden_dim,))
    V = rs.normal(size=(hidden_dim,))

    g = nx.DiGraph() if directed else nx.Graph()
    g.add_node(0)
    for i in range(1, num_nodes):
        g.add_node(i)
        h = np.tanh(rs.normal(size=(hidden_dim,)))
        prev = 0.0
        for j in range(i):
            if g.number_of_edges() >= num_edges:
                break
            h = np.tanh(W_h @ h + W_in[:, 0] * prev + b)
            z = float(V @ h)
            p = 1.0 / (1.0 + math.exp(-z))
            if rng.random() < p:
                g.add_edge(i, j)
                prev = 1.0
            else:
                prev = 0.0
    return g
